import { Euler, Matrix4, Mesh } from "three";
import { DEG_TO_RAD } from "../constants";
import { parseFMBEValue } from "./parseFMBEValue";
import { FMBE } from "./types";

export function updateMesh(fmbe: FMBE, mesh: Mesh): void {
	const px: number = parseFMBEValue(fmbe.position.x, 0);
	const py: number = parseFMBEValue(fmbe.position.y, 0);
	const pz: number = parseFMBEValue(fmbe.position.z, 0);
	const rx: number = parseFMBEValue(fmbe.rotation.x, 0) * DEG_TO_RAD;
	const ry: number = -parseFMBEValue(fmbe.rotation.y, 0) * DEG_TO_RAD;
	const rz: number = -parseFMBEValue(fmbe.rotation.z, 0) * DEG_TO_RAD;
	const bx: number = parseFMBEValue(fmbe.basePosition.x, 0) / 16;
	const by: number = parseFMBEValue(fmbe.basePosition.y, 0) / 16;
	const bz: number = parseFMBEValue(fmbe.basePosition.z, 0) / 16;
	const s: number = parseFMBEValue(fmbe.scale, 1);
	const es: number = parseFMBEValue(fmbe.extend.scale, 1);
	const ex: number = parseFMBEValue(fmbe.extend.rotation.x, -90) * DEG_TO_RAD;
	const ey: number = -parseFMBEValue(fmbe.extend.rotation.y, 0) * DEG_TO_RAD;
	const matShear: Matrix4 = new Matrix4();
	const rxMatrix: Matrix4 = new Matrix4().makeRotationX(ex);
	const ryMatrix: Matrix4 = new Matrix4().makeRotationY(ey);
	matShear.multiply(ryMatrix);
	matShear.multiply(rxMatrix);
	matShear.multiply(new Matrix4().makeScale(1, 1, es));
	matShear.multiply(rxMatrix.transpose());
	matShear.multiply(ryMatrix.transpose());
	const extendMatrix: Matrix4 = new Matrix4();
	extendMatrix.multiply(matShear);
	extendMatrix.multiply(new Matrix4().makeScale(1, es, 1));
	const translationMatrix: Matrix4 = new Matrix4().makeTranslation(px, py, pz);
	const finalMatrix: Matrix4 = new Matrix4();
	finalMatrix.multiply(translationMatrix);
	finalMatrix.multiply(new Matrix4().makeRotationFromEuler(new Euler(rx, ry, rz, "XYZ")));
	finalMatrix.multiply(new Matrix4().makeScale(s, s, s));
	finalMatrix.multiply(extendMatrix);
	finalMatrix.multiply(new Matrix4().makeTranslation(bx, by, bz));
	mesh.matrix.copy(finalMatrix);
	mesh.updateMatrixWorld(true);
}
